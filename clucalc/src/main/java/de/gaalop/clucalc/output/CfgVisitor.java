package de.gaalop.clucalc.output;

import de.gaalop.cfg.*;
import de.gaalop.clucalc.input.CluCalcFileHeader;
import de.gaalop.dfg.Expression;
import de.gaalop.dfg.MultivectorComponent;
import de.gaalop.dfg.Variable;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * Visits the control structure of the control dataflow graph.
 */
public class CfgVisitor implements ControlFlowVisitor {

	private Map<String, Set<Integer>> assignedComponents = new HashMap<String, Set<Integer>>();

	private StringBuilder code = new StringBuilder();

	private int indent;

	public String getCode() {
		return code.toString();
	}

	@Override
	public void visit(StartNode startNode) {
		CluCalcFileHeader header = CluCalcFileHeader.get(startNode);

		if (header != null) {
			if (header.getAlgebraMode() != null) {
				code.append(header.getAlgebraMode().getDefinitionMethod());
				code.append("();\n");
			}
			if (header.getNullSpace() != null) {
				switch (header.getNullSpace()) {
				case IPNS:
					code.append(":IPNS;\n");
					break;
				case OPNS:
					code.append(":OPNS;\n");
					break;
				}
			}
			code.append("\n");

		}

		// TODO add "Generated by" header etc.

		// Generate the local variables for all local variables
		for (Variable localVariable : startNode.getGraph().getLocalVariables()) {
			code.append(localVariable.getName());
			code.append(" = List(");
			code.append(startNode.getGraph().getBladeList().length);
			code.append(");\n");
		}

		code.append("\n");

		startNode.getSuccessor().accept(this);
	}

	@Override
	public void visit(EndNode node) {
	}

	@Override
	public void visit(AssignmentNode assignmentNode) {
		Set<Integer> assigned = assignedComponents.get(assignmentNode.getVariable().getName());
		if (assigned != null && assigned.isEmpty()) {
			// in this case the variable is reused and should be reset
			appendIndent();
			code.append(assignmentNode.getVariable().getName());
			code.append(" = List(32); // reset for reuse\n");
		}
		
		appendIndent();
		addCode(assignmentNode.getVariable());
		code.append(" = ");
		addCode(assignmentNode.getValue());
		if (assignmentNode.getVariable() instanceof MultivectorComponent) {
			code.append("; // ");

			MultivectorComponent component = (MultivectorComponent) assignmentNode.getVariable();
			Expression[] bladeList = assignmentNode.getGraph().getBladeList();

			DfgVisitor bladeVisitor = new DfgVisitor();
			bladeList[component.getBladeIndex()].accept(bladeVisitor);
			code.append(bladeVisitor.getCode());

			code.append("\n");

			// Record that this component has been set for the multivector
			if (!assignedComponents.containsKey(component.getName())) {
				assignedComponents.put(component.getName(), new HashSet<Integer>());
			}
			assignedComponents.get(component.getName()).add(component.getBladeIndex());
		} else {
			code.append(";\n");
		}

		assignmentNode.getSuccessor().accept(this);
	}
	
	@Override
	public void visit(ExpressionStatement node) {
		addCode(node.getExpression());
		code.append(";\n");
		
		node.getSuccessor().accept(this);
	}

	@Override
	public void visit(StoreResultNode node) {
		appendIndent();

		code.append('?');

		// Reassemble all output variables in the value
		Variable outputVariable = (Variable) node.getValue();

		code.append(outputVariable.getName());
		code.append(" = ");
		Set<Integer> var = assignedComponents.get(outputVariable.getName());
		if (var == null) {
			// no assignment for this variable at all -> 0
			code.append(0);
		} else {
			for (int i = 0; i < node.getGraph().getBladeList().length; ++i) {
				if (!var.contains(i)) {
					continue;
				}

				Expression blade = node.getGraph().getBladeList()[i];

				code.append(outputVariable.getName());
				code.append("(");
				code.append(i + 1);
				code.append(")");
				code.append(" * ");
				addCode(blade);
				code.append(" + ");
			}
			// Remove the last " + "
			code.setLength(code.length() - 3);
		}

		// reset the set of assigned components, so variable can be reused
		assignedComponents.put(outputVariable.getName(), new HashSet<Integer>());

		code.append(";\n");

		node.getSuccessor().accept(this);
	}

	@Override
	public void visit(IfThenElseNode node) {
		appendIndent();
		code.append("if (");
		addCode(node.getCondition());
		code.append(") {\n");
		indent++;

		node.getPositive().accept(this);

		indent--;
		appendIndent();
		code.append("}");

		if (node.getNegative() instanceof BlockEndNode) {
			code.append("\n");
		} else {
			code.append(" else ");

			boolean isElseIf = false;
			if (node.getNegative() instanceof IfThenElseNode) {
				IfThenElseNode ifthenelse = (IfThenElseNode) node.getNegative();
				isElseIf = ifthenelse.isElseIf();
			}
			if (!isElseIf) {
				code.append("{\n");
				indent++;
			}

			node.getNegative().accept(this);

			if (!isElseIf) {
				indent--;
				appendIndent();
				code.append("}\n");
			}
		}

		node.getSuccessor().accept(this);
	}
	
	@Override
	public void visit(LoopNode node) {
		appendIndent();
		code.append("loop {\n");
		indent++;
		node.getBody().accept(this);
		indent--;
		appendIndent();
		code.append("}\n");
		
		node.getSuccessor().accept(this);
	}
	
	@Override
	public void visit(BreakNode breakNode) {
		appendIndent();
		code.append("break;\n");
	}

	@Override
	public void visit(BlockEndNode node) {
		// nothing to do
	}

	private void addCode(Expression value) {
		DfgVisitor visitor = new DfgVisitor();
		value.accept(visitor);
		code.append(visitor.getCode());
	}

	private void appendIndent() {
		for (int i = 0; i < indent; i++) {
			code.append("\t");
		}
	}

	@Override
	public void visit(Macro node) {
		throw new IllegalStateException("Macros should have been inlined.");
	}
}
