package de.gaalop.clucalc.output;

import de.gaalop.cfg.*;
import de.gaalop.clucalc.input.CluCalcFileHeader;
import de.gaalop.dfg.Expression;
import de.gaalop.dfg.MultivectorComponent;
import de.gaalop.dfg.Variable;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * Visits the control structure of the control dataflow graph.
 */
public class CfgVisitor implements ControlFlowVisitor {

  private Map<String, Set<Integer>> assignedComponents = new HashMap<String, Set<Integer>>();

  private StringBuilder code = new StringBuilder();

  private int indent;

  public String getCode() {
    return code.toString();
  }

  @Override
  public void visit(StartNode startNode) {
    CluCalcFileHeader header = CluCalcFileHeader.get(startNode);

    if (header != null) {
      if (header.getAlgebraMode() != null) {
        code.append(header.getAlgebraMode().getDefinitionMethod());
        code.append("();\n");
      }
      if (header.getNullSpace() != null) {
        switch (header.getNullSpace()) {
        case IPNS:
          code.append(":IPNS;\n");
          break;
        case OPNS:
          code.append(":OPNS;\n");
          break;
        }
      }
      code.append("\n");

    }

    // TODO add "Generated by" header etc.

    // Generate the local variables for all local variables
    for (Variable localVariable : startNode.getGraph().getLocalVariables()) {
      code.append(localVariable.getName());
      code.append(" = List(");
      code.append(startNode.getGraph().getBladeList().length);
      code.append(");\n");
    }

    code.append("\n");

    startNode.getSuccessor().accept(this);
  }

  @Override
  public void visit(EndNode node) {
  }

  @Override
  public void visit(AssignmentNode assignmentNode) {
    appendIndent();
    addCode(assignmentNode.getVariable());
    code.append(" = ");
    addCode(assignmentNode.getValue());
    if (assignmentNode.getVariable() instanceof MultivectorComponent) {
      code.append("; // ");

      MultivectorComponent component = (MultivectorComponent) assignmentNode.getVariable();
      Expression[] bladeList = assignmentNode.getGraph().getBladeList();

      DfgVisitor bladeVisitor = new DfgVisitor();
      bladeList[component.getBladeIndex()].accept(bladeVisitor);
      code.append(bladeVisitor.getCode());

      code.append("\n");

      // Record that this component has been set for the multivector
      if (!assignedComponents.containsKey(component.getName())) {
        assignedComponents.put(component.getName(), new HashSet<Integer>());
      }
      assignedComponents.get(component.getName()).add(component.getBladeIndex());
    } else {
      code.append(";\n");
    }

    assignmentNode.getSuccessor().accept(this);
  }

  @Override
  public void visit(StoreResultNode node) {
    appendIndent();

    code.append('?');

    // Reassemble all output variables in the value
    Variable outputVariable = (Variable) node.getValue();

    code.append(outputVariable.getName());
    code.append(" = ");
    Set<Integer> var = assignedComponents.get(outputVariable.getName());
    if (var == null) {
      // no assignment for this variable at all -> 0
      code.append(0);
    } else {
      for (int i = 0; i < node.getGraph().getBladeList().length; ++i) {
        if (!var.contains(i)) {
          continue;
        }

        Expression blade = node.getGraph().getBladeList()[i];

        code.append(outputVariable.getName());
        code.append("(");
        code.append(i + 1);
        code.append(")");
        code.append(" * ");
        addCode(blade);
        code.append(" + ");
      }    
      // Remove the last " + "
      code.setLength(code.length() - 3);
    }

    code.append(";\n");

    node.getSuccessor().accept(this);
  }

  @Override
  public void visit(IfThenElseNode node) {
    appendIndent();
    code.append("if (");
    addCode(node.getCondition());
    code.append(") {\n");
    indent++;

    node.getPositive().accept(this);

    indent--;
    appendIndent();
    code.append("}");

    if (node.getNegative() instanceof BlockEndNode) {
      code.append("\n");
    } else {
      code.append(" else {\n");
      indent++;
      
      node.getNegative().accept(this);
      
      indent--;
      appendIndent();
      code.append("}\n");
    }

    node.getSuccessor().accept(this);
  }

  @Override
  public void visit(BlockEndNode node) {
    // nothing to do
  }

  private void addCode(Expression value) {
    DfgVisitor visitor = new DfgVisitor();
    value.accept(visitor);
    code.append(visitor.getCode());
  }

  private void appendIndent() {
    for (int i = 0; i < indent; i++) {
      code.append("\t");
    }
  }
}
