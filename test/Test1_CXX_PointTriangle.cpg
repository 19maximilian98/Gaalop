#include <gpc.h>

bool pointTriangleTest(const float t1x, const float t1y, const float t1z,
		const float t2x, const float t2y, const float t2z, const float t3x,
		const float t3y, const float t3z, const float px, const float py,
		const float pz, const float h) {
#pragma gcd begin
	// triangle properties
	TrianglePoint1 = VecN3(t1x, t1y, t1z);
	TrianglePoint2 = VecN3(t2x, t2y, t2z);
	TrianglePoint3 = VecN3(t3x, t3y, t3z);

	// point properties
	TestPoint = VecN3(px, py, pz);

	// construct plane
	plane = *(TrianglePoint1 ^ TrianglePoint2 ^ TrianglePoint3 ^ einf);

	// compute distance to plane
	?d = plane . TestPoint;

	// extract triangle normal
	?normal_ = plane - (plane . e0) ^ einf;

	// construct boundary planes
	side1 = *(TrianglePoint1 ^ TrianglePoint2 ^ normal_ ^ einf);
	side2 = *(TrianglePoint2 ^ TrianglePoint3 ^ normal_ ^ einf);
	side3 = *(TrianglePoint3 ^ TrianglePoint1 ^ normal_ ^ einf);

	// compute distances
	?d1 = side1 . TestPoint;
	?d2 = side2 . TestPoint;
	?d3 = side3 . TestPoint;
#pragma gcd end

	const float d_SCALAR = mv_get_bladecoeff(d,1);
	const float d1_SCALAR = mv_get_bladecoeff(d1,1);
	const float d2_SCALAR = mv_get_bladecoeff(d2,1);
	const float d3_SCALAR = mv_get_bladecoeff(d3,1);

	if (d_SCALAR * d_SCALAR > h * h)
		return false;

	if (d1_SCALAR <= 0.0f && d2_SCALAR <= 0.0f
			&& d3_SCALAR <= 0.0f || d1_SCALAR >= 0.0f
			&& d2_SCALAR >= 0.0f && d3_SCALAR >= 0.0f)
		return true;

	return false;
}

int main() {
	return !pointTriangleTest(0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f,
			0.0f, 0.2f, 0.2f, 0.0f, 0.1f);
}
